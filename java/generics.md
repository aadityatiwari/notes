[Generics in Java](https://en.wikipedia.org/wiki/Generics_in_Java)
------------------------------------------------------------------

Generics were added to Java in 2004 within the official version J2SE 5.0

The [Java collections framework](https://en.wikipedia.org/wiki/Java_collections_framework) supports generics to specify the type of objects stored in a collection instance.

According to *Java Language Specification*:

-   A **type variable** is an unqualified identifier. Type variables are introduced by generic class declarations, generic interface declarations, generic method declarations, and by generic constructor declarations.

-   A **class** is generic if it declares one or more type variables. These type variables are known as the type parameters of the class. It defines one or more type variables that act as parameters. A generic class declaration defines a set of parameterized types, one for each possible invocation of the type parameter section. All of these parameterized types share the same class at runtime.

-   An **interface** is generic if it declares one or more type variables. These type variables are known as the type parameters of the interface. It defines one or more type variables that act as parameters. A generic interface declaration defines a set of types, one for each possible invocation of the type parameter section. All parameterized types share the same interface at runtime.

-   A **method** is generic if it declares one or more type variables. These type variables are known as the formal type parameters of the method. The form of the formal type parameter list is identical to a type parameter list of a class or interface.

-   A **constructor** can be declared as generic, independently of whether the class that the constructor is declared in is itself generic. A constructor is generic if it declares one or more type variables. These type variables are known as the formal type parameters of the constructor. The form of the formal type parameter list is identical to a type parameter list of a generic class or interface.

Below is a Java code illustrates a problem that exists when not using generics:

```java
List v = new ArrayList();
v.add("test");
Integer i = (Integer)v.get(0); // Run time error

```

Although the code is compiled without error, it throws a runtime exception (java.lang.ClassCastException) when executing the third line of code. This type of problem can be avoided by using generics and is the primary motivation for using generics.

Using generics, the above code fragment can be rewritten as follows:

```java
List<String> v = new ArrayList<>();
v.add("test");
Integer i = v.get(0); // (type error)  compilation-time error

```

With generics, it is no longer necessary to cast the third line to any particular type, because the result of v.get(0) is defined as String by the code generated by the compiler.


[Wildcard (Java)](https://en.wikipedia.org/wiki/Wildcard_(Java))
---------------

The **wildcard** ? in [Java](https://en.wikipedia.org/wiki/Java_(programming_language)) is a special [type parameter](https://en.wikipedia.org/wiki/Type_parameter) that controls the type safety of the use of [generic](https://en.wikipedia.org/wiki/Generics_in_Java) (parameterized) types. It can be used in variable declarations and instantiations as well as in method definitions, but not in the definition of a generic type.

Wildcards are type arguments in the form "?", possibly with an upper or lower [bound](https://en.wikipedia.org/wiki/Bounded_quantification). 

An **unbounded wildcard, List&lt;?&gt;** indicates a list which has an unknown object type. Reading from the list will return objects of type Object, and adding non-[null](https://en.wikipedia.org/wiki/Null_pointer) elements to the list is not allowed, since the element type is not known.

Upper bounds are expressed using **extends** keyword and lower bounds using **super** keyword.

**Generic&lt;? extends Supertype&gt; **restricts compatibility to** Supertype and its children.**

**Generic&lt;? super Subtype&gt;** restricts compatibility to** Subtype and all its parents.**

To specify the [upper bound](https://en.wikipedia.org/wiki/Bounded_quantification) of a type wildcard, **extends** keyword is used, which indicates that the type argument is a subtype of the bounding class.

List**&lt;? extends Number&gt;** means that the given list contains objects of some unknown type which extend the Number class. For example, the list could be List&lt;Float&gt; or List&lt;Number&gt;. Reading an element from the list will return a Number, while **adding non-null elements is once again not allowed.**

Neither List&lt;Number&gt; nor List&lt;Integer&gt; is a subtype of the other, even though Integer is a subtype of Number. So, any method that takes List&lt;Number&gt; as a parameter does not accept an argument of List&lt;Integer&gt;.  If it did, it would be possible to insert a Number that is not an Integer into it, which violates type safety. Below is a sample code that explains the contradiction it brings if List&lt;Integer&gt; were a subtype of List&lt;Number&gt;:

```java
List<Integer> ints = new ArrayList<Integer>();
ints.add(2);
List<Number> nums = ints;  // valid if List<Integer> were a subtype of List<Number> according to substitution rule. 
nums.add(3.14);  
Integer x=ints.get(1); // now 3.14 is assigned to an Integer variable!

```

The solution with wildcards works because it disallows operations that would violate type safety.

```java
List<? extends Number> nums = ints;  // it is OK
nums.add(3.14); // it is prohibited
```

The use of wildcards above adds flexibility since there is not any inheritance relationship between any two parameterized types with concrete type as type argument. 

The solution with wildcards works because it disallows operations that would violate type safety.

To specify the **lower bounding** class of a type wildcard, the **super keyword** is used. This keyword indicates that the type argument is a supertype of the bounding class.

So, **List&lt;? super Number&gt;** could represent List&lt;Number&gt; or List&lt;Object&gt;.

Reading from a list defined as **List&lt;? super Number&gt;** returns elements of type Object. Adding to such a list requires elements of type Number or any super type of Number.

**Variance** refers to how subtyping between more complex types (list of Cats versus list of Animals, function returning Cat versus function returning Animal, ...) relates to subtyping between their components.

The mnemonic **PECS (Producer Extends, Consumer Super)** from the book **Effective Java** by [Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch) gives an easy way to remember when to use wildcards (corresponding to covariance and contra-variance) in Java.

No objects may be created with a wildcard type parameter; **new** **Generic&lt;?&gt;()** is **forbidden** because Generic&lt;?&gt; is abstract

**However, new ArrayList&lt;Generic&lt;?&gt;&gt;() is allowed**, because the wildcard is not a parameter to the instantiated type ArrayList.

An array object that is an array of a parameterized type can only parameterized by an unconstrained (i.e. with an unbound wildcard type parameter) type as the component type: 

**new** Generic&lt;?&gt;\[20\] is correct, 

while **new** Generic&lt;SomeType&gt;\[20\] is not.

```java
// Compiles
List<WildcardSample<Integer>> list2 = new ArrayList<WildcardSample<Integer>>();

// Compiles
List<WildcardSample<?>> list = new ArrayList<WildcardSample<?>>();

// Compiles
WildcardSample<?> array[] = new WildcardSample<?>[20];

// Compilation fails: Cannot create a generic array of WildcardSample<Integer>
WildcardSample<Integer> array2[] = new WildcardSample<Integer>[20];
```

An example in Java with a generic interface. The *Test.min* function uses simple bounded quantification and does not preserve the type of the assigned types, in contrast with the *Test.Fmin* function which uses F-bounded quantification.

```java
interface Comparable<T> {
  public int compareTo(T other);
}

class Integer implements Comparable<Integer> {
  @Override
  public int compareTo(Integer other) {
    //...
  }
}

class String implements Comparable<String> {
  @Override
  public int compareTo(String other) {
    //...
  }
}

class Test {
  public static void main(String[] args) {
    Comparable<String> a = min("cat", "dog");
    Comparable<Integer> b = min(new Integer(10), new Integer(3));
    String str = Fmin("cat", "dog");
    Integer i = Fmin(new Integer(10), new Integer(3));
  }

  public static <S extends Comparable> S min(S a, S b) {
    if (a.compareTo(b) <= 0)
      return a;
    else
      return b;
  }

  public static <T extends Comparable<T>> T Fmin(T a, T b) {
    if (a.compareTo(b) <= 0)
      return a;
    else
      return b;
  }
}

```

An example of a generic Java class, which can be used to represent individual entries (key to value mappings) in a [map](https://en.wikipedia.org/wiki/Map_(computer_science)):

```java
public class Entry<KeyType, ValueType> {
  
    private final KeyType key;
    private final ValueType value;

    public Entry(KeyType key, ValueType value) {  
        this.key = key;
        this.value = value;
    }

    public KeyType getKey() {
        return key;
    }

    public ValueType getValue() {
        return value;
    }

    public String toString() { 
        return "(" + key + ", " + value + ")";  
    }

}
```

Java SE 7 and above allow the programmer to substitute an empty pair of angle brackets (**&lt;&gt;**, called the ***diamond operator***) for a pair of angle brackets containing the one or more type parameters that a sufficiently-close context [implies](https://en.wikipedia.org/wiki/Type_conversion#implicit_type_conversion)

```java
Entry<String, String> grade = new Entry<>("Mike", "A");
Entry<String, Integer> mark = new Entry<>("Mike", 100);
System.out.println("grade: " + grade);
System.out.println("mark: " + mark);

Entry<Integer, Boolean> prime = new Entry<>(13, true);
if (prime.getValue()) System.out.println(prime.getKey() + " is prime.");
else System.out.println(prime.getKey() + " is not prime.");

```

The use of [primitive types](https://en.wikipedia.org/wiki/Primitive_type) is not allowed, and [boxed](https://en.wikipedia.org/wiki/Object_type_(object-oriented_programming)#Boxing) versions must be used instead:
```java
Entry<int, int> pair; // Fails compilation. Use Integer instead.
```


**Problems with type erasure**
--------

Generics are checked at compile-time for type-correctness. The compile-time check guarantees that the resulting code is type-correct.

**Type erasure** refers to the [compile-time](https://en.wikipedia.org/wiki/Compile_time) process by which explicit [type annotation](https://en.wikipedia.org/wiki/Type_signature) are removed from a program, before it is executed at [run-time](https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)). 

Because of type erasure, type parameters cannot be determined at run-time.

For example, when an ArrayList is examined at runtime, there is no general way to determine whether, before type erasure, it was an ArrayList&lt;Integer&gt; or an ArrayList&lt;Float&gt;. Many people are dissatisfied with this restriction

Another effect of type erasure is that a generic class cannot extend the Throwable class in any way, directly or indirectly.
```java
public class GenericException<T> extends Exception // Compilation-error
```
Due to type erasure, the runtime will not know which catch block to execute, so this is prohibited by the compiler.

```java
try {
    throw new GenericException<Integer>();
}
catch(GenericException<Integer> e) {
    System.err.println("Integer");
}
catch(GenericException<String> e) {
    System.err.println("String");
}

```

Java generics generate only one compiled version of a generic class or function regardless of the number of parameterizing types used.

The following code cannot be compiled as the type is unknown at the time of instantiation.

```java
<T> T instantiateElementType(List<T> arg) {
     return new T(); //causes a compile error
}

```

Because there is only one copy per generic class at runtime, static variables are shared among all the instances of the class, regardless of their type parameter. Consequently, the **type parameter cannot** **be used** in the declaration of **static variables or in static methods.**

In the Java Collections Framework, the class List&lt;MyClass&gt; represents an ordered collection of objects of type MyClass. Upper bounds are specified using extends: A List&lt;? extends MyClass&gt; is a list of objects of some subclass of MyClass, i.e. any object in the list is guaranteed to be of type MyClass, so one can iterate over it using a variable of type MyClass

```java
public void doSomething(List<? extends MyClass> list) {
  for(MyClass object : list) { // OK
    // do something
  }
}

```

However, it is not guaranteed that one can add any object of type MyClass to that list:

```java
public void doSomething(List<? extends MyClass> list) {
  MyClass m = new MyClass();
  list.add(m); // Compile error
}

```

The converse is true for lower bounds, which are specified using super: A List&lt;? super MyClass&gt; is a list of objects of some superclass of MyClass, i.e. the list is guaranteed to be able to contain any object of type MyClass, so one can add any object of type MyClass:

```java
public void doSomething(List<? super MyClass> list) {
  MyClass m = new MyClass();
  list.add(m); // OK
}

```

However, it is not guaranteed that one can iterate over that list using a variable of type MyClass:

```java
public void doSomething(List<? super MyClass> list) {
  for(MyClass object : list) { // Compile error
    // do something
  }
}

```

In order to be able to do both add objects of type MyClass to the list and iterate over it using a variable of type MyClass, a List&lt;MyClass&gt; is needed, which is the only type of List that is both List&lt;? extends MyClass&gt; and List&lt;? super MyClass&gt;

**Example:** Classes: A, B, C, and D where B, C, and D are direct subclass of A.

The ArrayList&lt;? extends A&gt; means an ArrayList of some unknown type that extends A.

That type might not be C, so you can't add a C to the ArrayList. In fact, since you don't know what the ArrayList is supposed to contain, you can't add anything to the ArrayList other than null. If you want an ArrayList that can hold any class that inherits A, use a ArrayList&lt;A&gt;.

[Generics in Java](https://en.wikipedia.org/wiki/Generics_in_Java)
------------------------------------------------------------------

Generics were added to Java in 2004 within the official version J2SE 5.0

The [Java collections framework](https://en.wikipedia.org/wiki/Java_collections_framework) supports generics to specify the type of objects stored in a collection instance.

According to *Java Language Specification*:

-   A **type variable** is an unqualified identifier. Type variables are introduced by generic class declarations, generic interface declarations, generic method declarations, and by generic constructor declarations.

-   A **class** is generic if it declares one or more type variables. These type variables are known as the type parameters of the class. It defines one or more type variables that act as parameters. A generic class declaration defines a set of parameterized types, one for each possible invocation of the type parameter section. All of these parameterized types share the same class at runtime.

-   An **interface** is generic if it declares one or more type variables. These type variables are known as the type parameters of the interface. It defines one or more type variables that act as parameters. A generic interface declaration defines a set of types, one for each possible invocation of the type parameter section. All parameterized types share the same interface at runtime.

-   A **method** is generic if it declares one or more type variables. These type variables are known as the formal type parameters of the method. The form of the formal type parameter list is identical to a type parameter list of a class or interface.

-   A **constructor** can be declared as generic, independently of whether the class that the constructor is declared in is itself generic. A constructor is generic if it declares one or more type variables. These type variables are known as the formal type parameters of the constructor. The form of the formal type parameter list is identical to a type parameter list of a generic class or interface.

Below is a Java code illustrates a problem that exists when not using generics:

```java
List v = new ArrayList();
v.add("test");
Integer i = (Integer)v.get(0); // Run time error

```

Although the code is compiled without error, it throws a runtime exception (java.lang.ClassCastException) when executing the third line of code. This type of problem can be avoided by using generics and is the primary motivation for using generics.

Using generics, the above code fragment can be rewritten as follows:

```java
List<String> v = new ArrayList<>();
v.add("test");
Integer i = v.get(0); // (type error)  compilation-time error

```

With generics, it is no longer necessary to cast the third line to any particular type, because the result of v.get(0) is defined as String by the code generated by the compiler.


[Wildcard (Java)](https://en.wikipedia.org/wiki/Wildcard_(Java))
---------------

The **wildcard** ? in [Java](https://en.wikipedia.org/wiki/Java_(programming_language)) is a special [type parameter](https://en.wikipedia.org/wiki/Type_parameter) that controls the type safety of the use of [generic](https://en.wikipedia.org/wiki/Generics_in_Java) (parameterized) types. It can be used in variable declarations and instantiations as well as in method definitions, but not in the definition of a generic type.

Wildcards are type arguments in the form "?", possibly with an upper or lower [bound](https://en.wikipedia.org/wiki/Bounded_quantification). 

An **unbounded wildcard, List&lt;?&gt;** indicates a list which has an unknown object type. Reading from the list will return objects of type Object, and adding non-[null](https://en.wikipedia.org/wiki/Null_pointer) elements to the list is not allowed, since the element type is not known.

Upper bounds are expressed using **extends** keyword and lower bounds using **super** keyword.

**Generic&lt;? extends Supertype&gt; **restricts compatibility to** Supertype and its children.**

**Generic&lt;? super Subtype&gt;** restricts compatibility to** Subtype and all its parents.**

To specify the [upper bound](https://en.wikipedia.org/wiki/Bounded_quantification) of a type wildcard, **extends** keyword is used, which indicates that the type argument is a subtype of the bounding class.

List**&lt;? extends Number&gt;** means that the given list contains objects of some unknown type which extend the Number class. For example, the list could be List&lt;Float&gt; or List&lt;Number&gt;. Reading an element from the list will return a Number, while **adding non-null elements is once again not allowed.**

Neither List&lt;Number&gt; nor List&lt;Integer&gt; is a subtype of the other, even though Integer is a subtype of Number. So, any method that takes List&lt;Number&gt; as a parameter does not accept an argument of List&lt;Integer&gt;.  If it did, it would be possible to insert a Number that is not an Integer into it, which violates type safety. Below is a sample code that explains the contradiction it brings if List&lt;Integer&gt; were a subtype of List&lt;Number&gt;:

```java
List<Integer> ints = new ArrayList<Integer>();
ints.add(2);
List<Number> nums = ints;  // valid if List<Integer> were a subtype of List<Number> according to substitution rule. 
nums.add(3.14);  
Integer x=ints.get(1); // now 3.14 is assigned to an Integer variable!

```

The solution with wildcards works because it disallows operations that would violate type safety.

```java
List<? extends Number> nums = ints;  // it is OK
nums.add(3.14); // it is prohibited
```

The use of wildcards above adds flexibility since there is not any inheritance relationship between any two parameterized types with concrete type as type argument. 

The solution with wildcards works because it disallows operations that would violate type safety.

To specify the **lower bounding** class of a type wildcard, the **super keyword** is used. This keyword indicates that the type argument is a supertype of the bounding class.

So, **List&lt;? super Number&gt;** could represent List&lt;Number&gt; or List&lt;Object&gt;.

Reading from a list defined as **List&lt;? super Number&gt;** returns elements of type Object. Adding to such a list requires elements of type Number or any super type of Number.

**Variance** refers to how subtyping between more complex types (list of Cats versus list of Animals, function returning Cat versus function returning Animal, ...) relates to subtyping between their components.

The mnemonic **PECS (Producer Extends, Consumer Super)** from the book **Effective Java** by [Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch) gives an easy way to remember when to use wildcards (corresponding to covariance and contra-variance) in Java.

No objects may be created with a wildcard type parameter; **new** **Generic&lt;?&gt;()** is **forbidden** because Generic&lt;?&gt; is abstract

**However, new ArrayList&lt;Generic&lt;?&gt;&gt;() is allowed**, because the wildcard is not a parameter to the instantiated type ArrayList.

An array object that is an array of a parameterized type can only parameterized by an unconstrained (i.e. with an unbound wildcard type parameter) type as the component type: 

**new** Generic&lt;?&gt;\[20\] is correct, 

while **new** Generic&lt;SomeType&gt;\[20\] is not.

```java
// Compiles
List<WildcardSample<Integer>> list2 = new ArrayList<WildcardSample<Integer>>();

// Compiles
List<WildcardSample<?>> list = new ArrayList<WildcardSample<?>>();

// Compiles
WildcardSample<?> array[] = new WildcardSample<?>[20];

// Compilation fails: Cannot create a generic array of WildcardSample<Integer>
WildcardSample<Integer> array2[] = new WildcardSample<Integer>[20];
```

An example in Java with a generic interface. The *Test.min* function uses simple bounded quantification and does not preserve the type of the assigned types, in contrast with the *Test.Fmin* function which uses F-bounded quantification.

```java
interface Comparable<T> {
  public int compareTo(T other);
}

class Integer implements Comparable<Integer> {
  @Override
  public int compareTo(Integer other) {
    //...
  }
}

class String implements Comparable<String> {
  @Override
  public int compareTo(String other) {
    //...
  }
}

class Test {
  public static void main(String[] args) {
    Comparable<String> a = min("cat", "dog");
    Comparable<Integer> b = min(new Integer(10), new Integer(3));
    String str = Fmin("cat", "dog");
    Integer i = Fmin(new Integer(10), new Integer(3));
  }

  public static <S extends Comparable> S min(S a, S b) {
    if (a.compareTo(b) <= 0)
      return a;
    else
      return b;
  }

  public static <T extends Comparable<T>> T Fmin(T a, T b) {
    if (a.compareTo(b) <= 0)
      return a;
    else
      return b;
  }
}

```

An example of a generic Java class, which can be used to represent individual entries (key to value mappings) in a [map](https://en.wikipedia.org/wiki/Map_(computer_science)):

```java
public class Entry<KeyType, ValueType> {
  
    private final KeyType key;
    private final ValueType value;

    public Entry(KeyType key, ValueType value) {  
        this.key = key;
        this.value = value;
    }

    public KeyType getKey() {
        return key;
    }

    public ValueType getValue() {
        return value;
    }

    public String toString() { 
        return "(" + key + ", " + value + ")";  
    }

}
```

Java SE 7 and above allow the programmer to substitute an empty pair of angle brackets (**&lt;&gt;**, called the ***diamond operator***) for a pair of angle brackets containing the one or more type parameters that a sufficiently-close context [implies](https://en.wikipedia.org/wiki/Type_conversion#implicit_type_conversion)

```java
Entry<String, String> grade = new Entry<>("Mike", "A");
Entry<String, Integer> mark = new Entry<>("Mike", 100);
System.out.println("grade: " + grade);
System.out.println("mark: " + mark);

Entry<Integer, Boolean> prime = new Entry<>(13, true);
if (prime.getValue()) System.out.println(prime.getKey() + " is prime.");
else System.out.println(prime.getKey() + " is not prime.");

```

The use of [primitive types](https://en.wikipedia.org/wiki/Primitive_type) is not allowed, and [boxed](https://en.wikipedia.org/wiki/Object_type_(object-oriented_programming)#Boxing) versions must be used instead:
```java
Entry<int, int> pair; // Fails compilation. Use Integer instead.
```
